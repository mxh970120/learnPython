import re

# 在正则表达式中，如果直接给出字符，就是精确匹配。用\d可以匹配一个数字，\w可以匹配一个字母或数字，所以：
# '00\d'可以匹配'007'，但无法匹配'00A'；
print(re.match(r'00\d', '007'))  # match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。
print(re.match(r'00\d', '00A'))
print('......................')
# '\d\d\d'可以匹配'010'；
print(re.match(r'\d\d\d', '010'))
print('......................')
# '\w\w\d'可以匹配'py3'；
print(re.match(r'\w\w\d', 'py3'))
print('......................')

# .可以匹配任意字符，所以：
# 'py.'可以匹配'pyc'、'pyo'、'py!'等等。
print(re.match(r'py.', 'py!'))
print('......................')

# \s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配' '，' '等；
print(re.match(r'\s+', ' '))
print('......................')
# 要匹配变长的字符，在正则表达式中，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符：
print(re.match(r'\d{3}', '333'))
print(re.match(r'\d{0,3}', '333'))  # {n,m}中间不能带空格
print('......................')

# [0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线；
print(re.match(r'[0-9a-zA-Z\_]', '_'))
print('......................')
# [0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'Py3000'等等；
print(re.match(r'[0-9a-zA-Z\_]+', 'Py3000'))
print('......................')
# [a-zA-Z\_][0-9a-zA-Z\_]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；
print(re.match(r'[a-zA-Z\_][0-9a-zA-Z\_]*', 'C333'))
print('......................')
# [a-zA-Z\_][0-9a-zA-Z\_]{0,19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。
print(re.match(r'[a-zA-Z\_][0-9a-zA-Z\_]{0,19}', 'A4444'))
print('......................')
# A|B可以匹配A或B，所以(P|p)ython可以匹配'Python'或者'python'。
print(re.match(r'(P|p)ython', 'python'))
print('......................')
# ^表示行的开头，^\d表示必须以数字开头。
print(re.match(r'^\d', '4'))
print(re.match(r'^\d', '4444'))  # 注意返回的match只有一个4，所以只会对第一个4做匹配
print('......................')
# $表示行的结束，\d$表示必须以数字结束。
print(re.match(r'\d$', '4'))
print(re.match(r'\d$', '4444'))  # 返回none，因为只匹配一个字符串
print('......................')


# 用正则表达式切分字符串比用固定的字符更灵活
print('a b   c'.split(' '))  # 无法识别连续的空格
print(re.split(r'\s+', 'a b   c'))  # 无论多少个空格都可以正常分割
print('......................')

# 除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。
m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
print(m)
print(m.group(0))  # 整个被匹配到的字符串
print(m.group(1))  # 子串1
print(m.group(2))  # 子串2
print('......................')

# 正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符
print(re.match(r'^(\d+)(0*)$', '102300').groups())  # 由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了
# 必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配
print(re.match(r'^(\d+?)(0*)$', '102300').groups())
print('......................')

# 如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配
re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
print(re_telephone.match('010-12345').groups())
